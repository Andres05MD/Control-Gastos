import { useState, useEffect } from "react";
import { collection, query, where, orderBy, onSnapshot, addDoc, deleteDoc, doc, updateDoc, serverTimestamp, arrayUnion, arrayRemove } from "firebase/firestore";
import { db, auth } from "@/lib/firebase";

export interface ShoppingItem {
    id: string;
    name: string;
    quantity: number;
    purchasedQuantity: number;
    price: number;
    completed: boolean;
}

export interface ShoppingList {
    id: string;
    userId: string;
    name: string;
    items: ShoppingItem[];
    createdAt: any;
}

export const useShoppingLists = () => {
    const [lists, setLists] = useState<ShoppingList[]>([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        let unsubscribeSnapshot: (() => void) | null = null;

        const unsubscribeAuth = auth.onAuthStateChanged((user) => {
            if (unsubscribeSnapshot) {
                unsubscribeSnapshot();
                unsubscribeSnapshot = null;
            }

            if (!user) {
                setLists([]);
                setLoading(false);
                return;
            }

            const q = query(
                collection(db, "shopping_lists"),
                where("userId", "==", user.uid),
                orderBy("createdAt", "desc")
            );

            unsubscribeSnapshot = onSnapshot(q, (snapshot) => {
                const data = snapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data(),
                })) as ShoppingList[];

                // Ensure backward compatibility by adding purchasedQuantity if missing
                const sanitizedData = data.map(list => ({
                    ...list,
                    items: list.items?.map(item => ({
                        ...item,
                        purchasedQuantity: item.purchasedQuantity ?? (item.completed ? item.quantity : 0)
                    })) || []
                }));

                setLists(sanitizedData);
                setLoading(false);
            });
        });

        return () => {
            unsubscribeAuth();
            if (unsubscribeSnapshot) {
                unsubscribeSnapshot();
            }
        };
    }, []);

    const createList = async (name: string) => {
        if (!auth.currentUser) return;
        await addDoc(collection(db, "shopping_lists"), {
            userId: auth.currentUser.uid,
            name,
            items: [],
            createdAt: serverTimestamp()
        });
    };

    const deleteList = async (listId: string) => {
        await deleteDoc(doc(db, "shopping_lists", listId));
    };

    const addItem = async (listId: string, item: Omit<ShoppingItem, "id" | "completed" | "purchasedQuantity">) => {
        const newItem: ShoppingItem = {
            id: crypto.randomUUID(),
            completed: false,
            purchasedQuantity: 0,
            ...item
        };
        const listRef = doc(db, "shopping_lists", listId);
        await updateDoc(listRef, {
            items: arrayUnion(newItem)
        });
    };

    const toggleItem = async (listId: string, currentItems: ShoppingItem[], itemId: string) => {
        const updatedItems = currentItems.map(item => {
            if (item.id === itemId) {
                const newCompleted = !item.completed;
                return {
                    ...item,
                    completed: newCompleted,
                    purchasedQuantity: newCompleted ? item.quantity : 0
                };
            }
            return item;
        });
        const listRef = doc(db, "shopping_lists", listId);
        await updateDoc(listRef, { items: updatedItems });
    };

    const updateItemProgress = async (listId: string, currentItems: ShoppingItem[], itemId: string, change: number) => {
        const updatedItems = currentItems.map(item => {
            if (item.id === itemId) {
                const newPurchasedQuantity = Math.max(0, Math.min(item.quantity, (item.purchasedQuantity || 0) + change));
                const completed = newPurchasedQuantity >= item.quantity;
                return {
                    ...item,
                    purchasedQuantity: newPurchasedQuantity,
                    completed
                };
            }
            return item;
        });
        const listRef = doc(db, "shopping_lists", listId);
        await updateDoc(listRef, { items: updatedItems });
    };

    const deleteItem = async (listId: string, currentItems: ShoppingItem[], itemId: string) => {
        const updatedItems = currentItems.filter(item => item.id !== itemId);
        const listRef = doc(db, "shopping_lists", listId);
        await updateDoc(listRef, { items: updatedItems });
    };

    const updateListName = async (listId: string, newName: string) => {
        const listRef = doc(db, "shopping_lists", listId);
        await updateDoc(listRef, { name: newName });
    };

    const duplicateList = async (listId: string) => {
        if (!auth.currentUser) return;
        const sourceList = lists.find(l => l.id === listId);
        if (!sourceList) return;

        const newItems = sourceList.items.map(item => ({
            ...item,
            id: crypto.randomUUID(), // New ID for the new item
            completed: false,
            purchasedQuantity: 0
        }));

        await addDoc(collection(db, "shopping_lists"), {
            userId: auth.currentUser.uid,
            name: `Copia de ${sourceList.name}`,
            items: newItems,
            createdAt: serverTimestamp()
        });
    };

    return { lists, loading, createList, deleteList, addItem, toggleItem, updateItemProgress, deleteItem, updateListName, duplicateList };
};
